1비트는 0,1중 한개를 저장
2비트면 00,01,10,11 4가지 가능 
32비트 2^32  #1비트 증가할 때마다 저장 단위는 2배로 늘어남 
8비트=1바이트는 숫자 2^8=256중 하나를 저장할 수 있는 크기임
부호표현--
0을 양수에 포함시킴 1바이트 기준으로 비트1개에 음수or양수 상태저장후 
나머지 비트7개에는 숫자를 저장. -128~127사이의 숫자 중 하나를 저장
ex_01111111 은127  10000000 은 -128 11111111 은 -1

자료형--
signed char 부호가 있는 1바이트 저장공간 #첫1비트는 부호비트 나머지7비트에 숫자를 저장 즉,-128~127의 숫자 중 하나를 저장할 수 있는크기
ex)기온
unsigned char 부호가 없는 1바이트 저장공간 #0	~256개의 숫자중 하나를 저장할 수 있는크기 ex)사람나이
signed short int  부호가 있는 2바이트 저장공간
1비트는 부호비트 나머지15비트에만 숫자를 저장 ex)d-day
unsigned short int 부호가 없는 2바이트 저장공간
2^16전체를 숫자 저장 공간으로 사영 65536개의 숫자 중 하나를 저장
signed long int 부호가 있는 4바이트 저장공간
unsigend long int 부호가 없는 4바이트 저장공간 2^32개의 숫자중 하나를 저장할 수 있는크기

실수형--
E2는 10^2을 의미 3.12567E2=312.567
float는 4바이트 double은 8바이트
float는 소수점이하6자리밖에안됨 6자리 이상 사용하려면 64비트기반인 double 자료형을 사용해야 합니다.

1장부록
빅 엔디언 방식:메모리에 값을 저장할때 메모리 주소가 낮은쪽에서 높은쪽으로 저장 /RISC기반의 유닉스와 리눅스가 이방식으로 바이트를 정렬
낮은주소 0x12 0x34 0x56 0x78 높은주소
리틀 엔디언 방식: 0X12345678을 4바이트 메모리에 저장할때 작은 자릿수의 값부터 저장 /CISC기반의 윈도우 운영체제는 이방식으로 바이트를 정렬
낮은주소 0x78 0x56 0x34 0x12 높은주소 

2장부록
공용체를 적재적소에 활용하면 메모리를 절약가능
typedef union convertdata{
    char c_data;  //1바이트
    short int s_data;  //2바이트
    int i_data;   //4바이트
}cd;

cd temp;  //union convertdata temp;와 같음
//공용체의 요소들은 할당된 메모리를 공유
공용체로 만든 자료형의 크기는 요소 중 가장큰 요소의 크기와 동일

전처리기 #define과 사용자 정의 자료형을 만드는typedef문법 헷갈리지말자

typedef unsigend short int* psi;  //psi라는 새자료형을 정의
#define psi unsigned short int*  // 위치가 반대!!

*p++: 자신이 가리키는 주소에 저장된 값을 사용한후 자신의 주소를 증가
*++p: 자신의주소를 증가시킨 후에 그 주소에 가서 값을 사용
++*p: p가 가지고 있는 주소에 저장된 값을 1만큼증가
